(function() {
   /**
   * Creates a DOM element with specified attributes
   * @private
   * @param {string} tag - HTML tag name
   * @param {Object} options - Element attributes and properties
   * @returns {HTMLElement}
   */
  function createElement (tag, { className, textContent, innerHTML, events = {}, ...attributes }) {
    const element = document.createElement(tag);

    if (className) element.className = className;

    if (innerHTML !== undefined) {
      element.innerHTML = innerHTML;
    } else if (textContent !== undefined) {
      element.textContent = textContent;
    }

    Object.entries(attributes).forEach(([key, value]) => {
      if (value !== undefined && value !== null) { 
        element.setAttribute(key, value);
      }
    });

    Object.entries(events).forEach(([event, handler]) => {
      if (typeof handler === 'function') { 
        element.addEventListener(event, handler);
      }
    });
    return element;
  }

  class Tutorial {
    #container = null;
    #course = {};
    #actions = [];
    #steps = [];


    /**
     * Initializes the form with provided data
     * @public
     * @param {Object} data - Initial form data
     */

    init(data) {
      this.#validateInitData(data);
      this.#course = this.#extractCourseData(data);
      this.#actions = this.#deepCloneActions(data.actions);
      this.#updateSteps();
      this.#render();   
    }

    /**
     * Validates initialization data
     * @private
     * @throws {Error} If validations fails
     */
    #validateInitData(data) {
      if (!data?.actions?.length) {
        this.#sendError('Initialization failed: Invalid or empty action data');
        throw new Error('Invalid or missing actions data');
      }
    }

    /**
     * Extracts course data from input
     * @private
     * @returns {Object} Course data
     */
    #extractCourseData({ id, bg_color, first_img, second_img, animal }) {
      return { 
        id, 
        bg_color, 
        first_img, 
        second_img,
        animal: animal && typeof animal === 'string' ? animal : 'dog'
       }
    }

    /**
     * Creates a deep clone of actions
     * @private
     * @returns {Array} Cloned actions
     */
    #deepCloneActions (actions) {
      return actions.map(action => ({
        ...action,
        tasks: [...action.tasks]
      }));
    }

    /**
     * Gets footprint directions based on action count
     * @private
     * @returns {Array|null} Array of directions
     */
    #getFootprintDirections() {
      const length = this.#actions.length;
      const directions = {
        6: ['right', 'left', 'left', 'right', 'right'],
        5: ['right', 'left', 'right', 'right'],
        4: ['right', 'left', 'right'],
        3: ['right', 'right']
      };

      return directions[length] || null;
    }

    /**
     * Finds index of first incomplete action
     * @private
     * @returns {number} Index or length of actions
     */
    #findFirstIncompleteActionIndex () {
      return this.#actions.findIndex(
        action => !action.tasks.every(task => task.status === 1)
      ) ?? this.#actions.length;
    }

    /**
     * Generates step class name
     * @private
     * @returns {string} Class name
     */
    #getStepClassName (isFirst, isLast, isCompleted) {
      return `tutorial-action${isFirst ? ' tutorial-action--first' : ''}${
        isLast ? ' tutorial-action--end' : ''
      }${isCompleted ? ' tutorial-action--done' : ''}`;
    }

    /**
     * Creates a single step object
     * @private
     * @returns {Object} Step configuration
     */
    #createStep(action, index, footprintDirections, firstIncompleteIndex) {
      const isFirst = index === 0;
      const isLast = index === this.#actions.length - 1;
      const isCompleted = action.tasks.every(task  => task.status === 1);
      const animal = index === firstIncompleteIndex ? `./images/${this.#course.animal}/icon-${this.#course.animal}.png` : undefined; 

      return {
        className: this.#getStepClassName(isFirst, isLast, isCompleted),
        task: {
          icon: `./images/icon/icon-${action.icon}.png`,
          content: action.title,
          animal,
          actionId: action.id
        },
        footer: this.#createFooter(isLast, isCompleted, index, footprintDirections),
        text: isFirst ? 'Start' : undefined,
        bg_color: action.bg_color,
        completed: isCompleted,
        isFirst
      }
    }

    /**
     * Maps actions to steps for rendering
     * @private
     */
     #updateSteps() {
      const footprintDirections = this.#getFootprintDirections();
      const firstIncompleteIndex = this.#findFirstIncompleteActionIndex();
      
      this.#steps = this.#actions.map((action, index) => 
        this.#createStep(action, index, footprintDirections, firstIncompleteIndex)
      );
    }

    /**
     * Converts number to word
     * @private
     * @returns {string} Word representation
     */
    #numberToWord (num) {
      const words = ['first', 'second', 'third', 'fourth', 'fifth'];
      return words[num - 1] || `step${num}`;
    }

    /**
     * Renders the tutorial structure
     * @private
     */
    #render() {
      if(!this.#container) this.#createContainer();
      this.#refreshUI();
    }

    /**
     * Refreshes the UI with updated steps
     * @private
     */
    #refreshUI() { 
      this.#container.innerHTML = '';
      const wrapperInner = createElement('div', { className : 'tutorial-wrapper-inner'});
      const wrapper =  createElement('div', { className: 'tutorial-wrapper' });

      this.#steps.forEach(step => {
        const action = this.#createActionElement(step);
        console.log(action)
        wrapper.appendChild(action);
      });

      wrapperInner.append(
        wrapper,
        this.#createDecorativeImage('first', this.#course.first_img),
        this.#createDecorativeImage('second', this.#course.second_img),
      );

      this.#container.appendChild(wrapperInner);
    }

    /**
     * Creates action element
     * @private
     * @param {HTMLElement} Action element 
     */
    #createActionElement (step) {
      const action = createElement('div', { className: step.className });
      const actionWrapper = createElement('div', { className: 'tutorial-action-wrapper'});

      actionWrapper.appendChild(this.#createActionLabel(step.task, step.isFirst));
      if (step.task) {
        actionWrapper.appendChild(createElement('div', {
          className: 'tutorial-text',
          textContent: step.text 
        }));
      }

      action.append(actionWrapper, this.#createFootPrint(step))
      return action;
    }
    
    /**
     * Creates decorative image element
     * @private
     * @returns {HTMLElement} Image container
     */
    #createDecorativeImage(position, src) {
      const container = createElement('div', {
        className: `decorative-image decorative-image--${position}`,
        'data-total-action': this.#actions.length
      });
      container.appendChild(this.#createImage(src));
      return container;
    }


    /**
     * Creates footprint element
     * @private
     * @returns {HTMLElement} Footer element
     */
    #createFootPrint ({ footer, completed }) {
      return footer.type === 'footprint'
        ? this.#createFootprintElement(footer, completed)
        : this.#createFlagElement(footer);
    }

    /**
     * Creates footprint element
     * @private
     * @returns {HTMLElement} Footprint element
     */
    #createFootprintElement (footer, completed) {
      const { className, foot } = footer;
      const footprint = createElement('div', {
        className: `tutorial-action-footprint ${className}`,
        'data-total-action': this.#actions.length 
      })

      const inner = createElement('div', {
        className: `tutorial-action-footprint-inner${completed ? ' finished' : ' unfinished'} direction-${foot.direction}`
      });

      for (let i = 0; i < foot.count; i++) {
        inner.appendChild(this.#createImage(foot.src));
      }
      footprint.appendChild(inner);
      return footprint;
    }

    
    /**
     * Creates flag element
     * @private
     * @returns {HTMLElement} Flag element
     */
    #createFlagElement(footer) {
      const { src, text } = footer;
      const flag = createElement('div', { className: 'tutorial-flag-end' });
      const imgFlag = createElement('div', { className: 'img-flag' });
      imgFlag.appendChild(this.#createImage(src));
      flag.append(
        imgFlag,
        createElement('div', { className: 'tutorial-text', textContent: text })
      );

      return flag;
    }

    /**
     * Updates action status
     * @public
     * @param {number} actionId - Action ID
     * @param {Array} taskUpdates - Task updates
     */
     updateActionStatus(actionId, taskUpdates) { 
      if(!this.#validateUpdateInputs(actionId, taskUpdates)) return;

      const actionIndex = this.#actions.findIndex(a => a.id === actionId);
      if (actionIndex === -1 || !this.#isPreviousComplete(actionIndex)) return;
      
      const updated = this.#updateTasks(actionId, actionIndex, taskUpdates);
      
      if (updated) {
        this.#updateSteps();
        this.#refreshUI();
      }
     }

     /**
      * Validates update inputs
      * @private
      * @returns {boolean} Validation result
      */
    #validateUpdateInputs(actionId, taskUpdates) {  
      if (!Number.isInteger(actionId)) {
        this.#sendError(`Invalid action ID: ${actionId}`, { actionId });
        return false;
      }
      if (!Array.isArray(taskUpdates) || !taskUpdates.every(t => Number.isInteger(t.taskId) && 'status' in t)) {
        this.#sendError('Action must be an array of {taskId, status} objects', { taskUpdates });
        return false;
      }
      return true;
    }

    /**
     * Checks if previous actions are complete
     * @private
     * @returns {boolean} Completion status
     */
    #isPreviousComplete(actionIndex) { 
      const isPreviousComplete = this.#actions
        .slice(0, actionIndex)
        .every(action => action.tasks.every(task => task.status === 1));

      console.log(isPreviousComplete)
      if (!isPreviousComplete) {
        this.#sendError(`Cannot update action because previous actions are incomplete`, { actionIndex });
        return false;
      }
      return true;
    }

    #updateTasks (actionId, actionIndex, taskUpdates) {
      const action = this.#actions[actionIndex];
      let updated = false;

      taskUpdates.forEach(update => {
        const task = action.tasks.find(t => t.id === update.taskId);
        if (task) {
          task.status = update.status === 1 ? 1 : 0;
          updated = true;
        } else {
          console.warn(`Task with ID ${update.taskId} not found in action ${actionId}`);
        }
      });

      return updated;
    }

    /**
     * Creates the main container structure
     * @private
     */
    #createContainer () {
      document.body.style.setProperty('--bg-body', this.#course.bg_color);
      this.#container = createElement('div', { className: 'tutorial' });
      document.body.prepend(this.#container);
    }

    /**
     * Creates action label element
     * @private
     * @returns {HTMLElement} Task element
     */
    #createActionLabel ({ actionId, icon, content, animal }, isFirst) { 
      const actionItem = createElement('div', {
        className: 'tutorial-task',
        events:  { click: () => this.#evtHandleAction(actionId) }
      });

      if (animal) {
        actionItem.appendChild(this.#createAnimalElement(animal))
      }

      actionItem.appendChild(this.#createCheckmarkElement(isFirst));
      actionItem.appendChild(this.#createTaskInnerElement(icon, content));
      return actionItem
    }

    /**
     * Creates animal element
     * @private
     * @returns {HTMLElement} Animal element
     */
    #createAnimalElement (animal) {
      const animalDiv = createElement('div', { className: 'tutorial-animal', 'data-total-action': this.#actions.length });
      animalDiv.appendChild(this.#createImage(animal));
      return animalDiv
    }

    /**
     *  Creates action label inner element
     * @private
     * @returns {HTMLElement} Action label inner element
     */
    #createTaskInnerElement(icon, content) { 
      const inner = createElement('div', { className: 'tutorial-task-inner' });
      const iconDiv = createElement('div', { className: 'task-icon' });
      iconDiv.appendChild(this.#createImage(icon));

      inner.append(
        iconDiv,
        createElement('div', { className: 'task-content text-nowrap', innerHTML: content})
      )
      return inner
    }

    /**
     * Creates checkmark element
     * @private
     * @param {Boolean} isFirst 
     * @returns {HTMLElement} Checkmark element
     */
    #createCheckmarkElement(isFirst) { 
      const checkmark = createElement('div', { className: 'checkmark-finished' });
      const checkmarkInner = createElement('div', { className: 'checkmark-inner' });
      const txtCheckMark = createElement('span', { textContent: 'Complete!' });

      checkmarkInner.append(
        this.#createImage('./images/icon-active/checkmark-finished.png'),
        !isFirst ? txtCheckMark : ''
      );
      checkmark.appendChild(checkmarkInner);
      return checkmark;
    }

    /**
     * Creates image element
     * @private
     * @returns {HTMLElement} Image element
     */
    #createImage(src) {
      return createElement('img', { src, alt: ''});
    }

    /**
     * Creates footer configuration
     * @private
     * @returns {Object} Footer configuration
     */
    #createFooter(isLast, isCompleted, index, footprintDirections) {
      if (isLast) {
        return {
          type: 'flag',
          src: isCompleted ? './images/icon/icon-flag-finished.png' : './images/icon/icon-flag.png',
          text: 'GOAL'
        }
      }

      return {
        type: 'footprint',
        className: `tutorial-action-footprint--${this.#numberToWord(index + 1)}`,
        foot: {
          count: index === 0 ? 3 : 2,
          src: `./images/${this.#course.animal}/footprint${
            isCompleted ? '-finished' : ''
          }.png`,
          direction: `${footprintDirections[index]}`
        }
      }
    }


    #sendError (message, details = {}) {
      this.postMessage('handleError', {
        type: 'error',
        message,
        details
      })
    }

    #evtHandleAction (actionId) {
      const actionIndex = this.#actions.findIndex(a => a.id === actionId);
      if (actionIndex === -1 || !this.#isPreviousComplete(actionIndex)) return;

      this.postMessage('openTask', {
          actionId,
          tasks: this.#actions[actionIndex].tasks
      });
    }

    postMessage (fncName, msg) {
      console.log(msg);
      if (!fncName || typeof fncName !== 'string') {
        console.error('The function name must be a valid string.');
        return;
      }

      try {
        const target = window[fncName];
        if (target?.postMessage) {
          target.postMessage(JSON.stringify(msg));
        } else {
          console.warn(`The function ${fncName} does not exist or does not support postMessage`);
        }
      } catch (error) {
        console.error('An error occurred while calling the postMessage function:', error);
      }
    }
  }

  const tutorial = new Tutorial();

  window.initTutorialApp = function (data) { 
    let e = null; 
    let isSuccess = false;
    try {
      tutorial.init(data);
      isSuccess = true;
    } catch (error) {
      e = error.message;
    }
    tutorial.postMessage('loadFinished', {error: e, "success": isSuccess});
    return isSuccess; 
  }

  window.initTutorialApp({
    "id": 1,
    "course_id": 101,
    "action_code": "string20",
    "type": "flow_chart",
    "title": "Mở course, server quay về mục tiêu background trình trạng admin",
    "title_color": "#000000",
    "bg_color": "#f0f0f0",
    "icon": "flowchart",
    "first_img": "./images/icon/icon-ball.png",
    "second_img": "./images/icon/icon-bone.png",
    "thumb_img": "path/to/thumb_image.jpg",
    "animal": "dog",
    "actions": [
      {
        "id": 1,
        "action_code": "act01",
        "title": "動画で学ぼう！Excel入門",
        "bg_color": "#e0e0e0",
        "icon": "dumbbell",
        "tasks": [
          {
            "id": 1,
            "task_code": "task01",
            "title": "Hành động trong trình trạng admin",
            "bg_color": "#d0d0d0",
            "icon": "dog",
            "order": 1,
            "status": 1,
            "finished": 0
          },
          {
            "id": 2,
            "task_code": "task02",
            "title": "Chuẩn bị dữ liệu",
            "bg_color": "#c0c0c0",
            "icon": "data",
            "order": 2,
            "status": 1,
            "finished": 0
          }
        ]
      },
      {
        "id": 2,
        "action_code": "act02",
        "title": "オンライン講座で復習！",
        "bg_color": "#b0b0b0",
        "icon": "phone",
        "tasks": [
          {
            "id": 3,
            "task_code": "task03",
            "title": "Tăng kỹ năng Excel",
            "bg_color": "#a0a0a0",
            "icon": "chart",
            "order": 1,
            "status": 1,
            "finished": 0
          },
          {
            "id": 4,
            "task_code": "task04",
            "title": "Phân tích dữ liệu",
            "bg_color": "#909090",
            "icon": "analyze",
            "order": 2,
            "status": 1,
            "finished": 0
          },
          {
            "id": 5,
            "task_code": "task05",
            "title": "Tối ưu hóa công việc",
            "bg_color": "#808080",
            "icon": "optimize",
            "order": 3,
            "status": 1,
            "finished": 0
          }
        ]
      },
      {
        "id": 3,
        "action_code": "act03",
        "title": `<small>今のレベルをチェック！</small><br/>
                        スキルチェックテスト①`,
        "bg_color": "#707070",
        "icon": "note",
        "tasks": [
          {
            "id": 6,
            "task_code": "task06",
            "title": "Thử thách nhỏ",
            "bg_color": "#606060",
            "icon": "pencil",
            "order": 1,
            "status": 0,
            "finished": 0
          }
        ]
      },
      {
        "id": 4,
        "action_code": "act03",
        "title": "もっと便利に！ショートカットキー",
        "bg_color": "#707070",
        "icon": "material",
        "tasks": [
          {
            "id": 7,
            "task_code": "task06",
            "title": "Thử thách nhỏ",
            "bg_color": "#606060",
            "icon": "pencil",
            "order": 1,
            "status": 0,
            "finished": 0
          }
        ]
      },
      {
        "id": 5,
        "action_code": "act03",
        "title": "抑えておきたい！基本の関数",
        "bg_color": "#707070",
        "icon": "star",
        "tasks": [
          {
            "id": 8,
            "task_code": "task06",
            "title": "Thử thách nhỏ",
            "bg_color": "#606060",
            "icon": "pencil",
            "order": 1,
            "status": 0,
            "finished": 0
          }
        ]
      },
      {
        "id": 6,
        "action_code": "act03",
        "title": "抑えておきたい！基本の関数",
        "bg_color": "#707070",
        "icon": "chart",
        "tasks": [
          {
            "id": 9,
            "task_code": "task06",
            "title": "Thử thách nhỏ",
            "bg_color": "#606060",
            "icon": "pencil",
            "order": 1,
            "status": 0,
            "finished": 0
          }
        ]
      }
    ],
    "course_code": "string20",
    "order": 1,
    "status": 0
  });

  tutorial.postMessage('javascriptLoaded', {"success": true});

  window.updateActionStatus = function (actionIndex, tasks) {
    tutorial.updateActionStatus(actionIndex, tasks)
  }
  //updateActionStatus(3, [
  //   { taskId: 6, status: 1 },
  // ])
})();